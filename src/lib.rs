// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

use std::fmt::Debug;

use der::asn1::{BitString, Uint};
use der::Any;
use spki::{AlgorithmIdentifier, ObjectIdentifier, SubjectPublicKeyInfoOwned};
use thiserror::Error;
use x509_cert::certificate::{Profile, TbsCertificateInner};
use x509_cert::ext::Extensions;
use x509_cert::name::Name;
use x509_cert::time::Validity;

/// Represents a signature algorithm usable in X.509-like environments.
pub trait SignatureAlgorithm: From<AlgorithmIdentifier<Any>> {
    /// Object ID notation of this signature algorithm
    fn oid(&self) -> ObjectIdentifier;
    /// Parameters for this signature algorithm. The contents of this parameters field will vary
    /// according to the algorithm identified.
    fn parameters(&self) -> Option<Any>;
    /// The signature algorithms' common name
    fn name(&self) -> &str;
}

/// A signature value, generated using a [`SignatureAlgorithm`]
pub trait Signature {
    type SignatureAlgorithm: SignatureAlgorithm;
    type Signature;
    /// The signature value
    fn signature(&self) -> &Self::Signature;
    /// The [`SignatureAlgorithm`] used to create this signature.
    fn algorithm(&self) -> &Self::SignatureAlgorithm;
}

/// A cryptographic private key generated by a [`SignatureAlgorithm`], with
/// a corresponding [`PublicKey`]
pub trait PrivateKey<T: SignatureAlgorithm> {
    type PrivateKey;
    type PublicKey: PublicKey<T>;
    type Signature: Signature;
    /// Returns a shared reference to [`Self::PrivateKey`]
    fn key(&self) -> &Self::PrivateKey;
    /// Returns an exclusive reference to [`Self::PrivateKey`]
    fn key_mut(&mut self) -> &mut Self::PrivateKey;
    /// The public key corresponding to this private key.
    fn pubkey(&self) -> &Self::PublicKey;
    /// Creates a [`Signature`] for the given data.
    fn sign(&self, data: &[u8]) -> Self::Signature;
}

/// A cryptographic public key generated by a [`SignatureAlgorithm`].
pub trait PublicKey<T: SignatureAlgorithm> {
    type PublicKey;
    type Signature: Signature;
    /// Returns a shared reference to [`Self::PublicKey`]
    fn key(&self) -> &Self::PublicKey;
    /// Returns an exclusive reference to [`Self::PublicKey`]
    fn key_mut(&mut self) -> &mut Self::PublicKey;
    /// Verify the correctness of a given [`Signature`] for a given piece of data.
    ///
    /// Implementations of this associated method should mitigate against signature malleability
    fn verify_signature(&self, signature: &Self::Signature, data: &[u8]) -> Result<(), impl Debug>;
}

pub struct IdCert<S: Signature, T: SignatureAlgorithm> {
    pub tbs_certificate: IdCertTbs<T>,
    pub signature: S,
}

pub struct IdCertTbs<T: SignatureAlgorithm> {
    pub serial_number: Uint,
    pub signature_algorithm: T,
    pub issuer: Name,
    pub validity: Validity,
    pub subject: Name,
    pub subject_public_key_info: SubjectPublicKeyInfo<T>,
    pub subject_unique_id: BitString,
    pub extensions: Extensions,
}

pub struct SubjectPublicKeyInfo<T: SignatureAlgorithm> {
    pub algorithm: T,
    pub subject_public_key: BitString,
}

impl<T: SignatureAlgorithm> From<SubjectPublicKeyInfoOwned> for SubjectPublicKeyInfo<T> {
    fn from(value: SubjectPublicKeyInfoOwned) -> Self {
        SubjectPublicKeyInfo {
            algorithm: value.algorithm.into(),
            subject_public_key: value.subject_public_key,
        }
    }
}

impl<T: SignatureAlgorithm, P: Profile> TryFrom<TbsCertificateInner<P>> for IdCertTbs<T> {
    type Error = TbsCertToIdCert;

    fn try_from(value: TbsCertificateInner<P>) -> Result<Self, Self::Error> {
        let subject_unique_id = match value.subject_unique_id {
            Some(suid) => suid,
            None => return Err(TbsCertToIdCert::SubjectUid),
        };

        let extensions = match value.extensions {
            Some(ext) => ext,
            None => return Err(TbsCertToIdCert::Extensions),
        };

        let subject_public_key_info =
            SubjectPublicKeyInfo::<T>::from(value.subject_public_key_info);

        let serial_number = match Uint::new(value.serial_number.as_bytes()) {
            Ok(snum) => snum,
            Err(e) => return Err(TbsCertToIdCert::Signature(e.to_string())),
        };

        Ok(IdCertTbs {
            serial_number,
            signature_algorithm: value.signature.into(),
            issuer: value.issuer,
            validity: value.validity,
            subject: value.subject,
            subject_public_key_info,
            subject_unique_id,
            extensions,
        })
    }
}

// impl<T: SignatureAlgorithm, P: Profile> TryFrom<IdCertTbs<T>> for TbsCertificateInner<P> {
//     type Error = IdCertToTbsCert;

//     fn try_from(value: IdCertTbs<T>) -> Result<Self, Self::Error> {
//         let serial_number = x509_cert::serial_number::SerialNumber::new(value.serial_number.to_b)
//         Ok(TbsCertificateInner {
//             version: x509_cert::Version::V3,
//             serial_number,
//             signature: todo!(),
//             issuer: todo!(),
//             validity: todo!(),
//             subject: todo!(),
//             subject_public_key_info: todo!(),
//             issuer_unique_id: todo!(),
//             subject_unique_id: todo!(),
//             extensions: todo!(),
//         })
//     }
// }

#[derive(Error, Debug, PartialEq)]
pub enum TbsCertToIdCert {
    #[error("field 'subject_unique_id' was None. Expected: Some(der::asn1::BitString)")]
    SubjectUid,
    #[error("field 'extensions' was None. Expected: Some(x509_cert::ext::Extensions)")]
    Extensions,
    #[error("Supplied integer too long")]
    Signature(String),
}

pub enum IdCertToTbsCert {}

// DOCUMENTME: Document above things
// TODO: Add TryFrom<IdCertTbs<T>> for TbsCertificateInner<P> implementation
// DOCUMENTME: When converting a X509Cert into an ID-Cert, it should at least be documented that this
//             certificate is not necessarily trusted and that the claims presented in the certificate
//             need to be verified first.

#[cfg(test)]
mod test {
    use der::asn1::Uint;
    use x509_cert::certificate::Profile;
    use x509_cert::serial_number::SerialNumber;

    #[derive(Clone, PartialEq, Eq, Debug)]
    enum TestProfile {}

    impl Profile for TestProfile {}

    #[test]
    fn test_convert_serial_number() {
        let biguint = Uint::new(&[10u8, 240u8]).unwrap();
        assert_eq!(biguint.as_bytes(), &[10u8, 240u8]);
        let serial_number: SerialNumber<TestProfile> =
            SerialNumber::new(biguint.as_bytes()).unwrap();
        assert_eq!(serial_number.as_bytes(), biguint.as_bytes());

        let biguint = Uint::new(&[240u8, 10u8]).unwrap();
        assert_eq!(biguint.as_bytes(), &[240u8, 10u8]);
        let serial_number: SerialNumber<TestProfile> =
            SerialNumber::new(biguint.as_bytes()).unwrap();
        assert_eq!(
            serial_number.as_bytes().strip_prefix(&[0]).unwrap(),
            biguint.as_bytes()
        );
    }
}
